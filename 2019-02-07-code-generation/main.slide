

Write less (code), generate more
Exploring code generation in Go
7 Feb 2019

Paul Jolly
modelogiq
paul@myitcv.io
https://myitcv.io
@_myitcv

: I am Paul
: Co-organiser of London Gophers
: Enjoy building tools in Go, including code generators

* Today we will

- examine the principles of code generation
- discover the main parts of a code generator
- look at some popular code generators
- write a simple code generator
- see how code generation fits into developer workflow
- inspire everyone to join the golang-tools community of tool builders!

.image images/tool_gopher.png 200 _
.caption Gopherize.me artwork courtesy of Ashley McNamara

: The goal of this talk is to equip and inspire people to experiment with code generation in their development workflow,
: and therefore become more efficient/effective at writing software/software engineering in the process.

* What do we mean by code generation?

Code generation is the process of generating code.

Code generators are the things that generate code.

.image images/code_gen_output.png _ 900

: Quick show of hands: who here has written some (Go) code?

* What is a code generator?

Humans are code generators:

- very creative
- good at problem solving
- not good at repetitive, robotic tasks

.image images/homer.png 300 _
.caption ©2006 Twentieth Century Fox Film Corporation

* What is a code generator?

Programs can be code generators:

- a computer program can write a computer program
- (currently) no creative or problem solving abilities
- good at repetitive, robotic tasks

.image images/gopher.png 300 _
.caption _Gopher_ by [[http://www.reneefrench.com][Renée French]]

* What code can be generated?

.image images/languages.jpg 500 _
.caption Image taken from codeinstitute.net

* But what about the input(s)?

- Code
- Configuration
- Metadata
- Environment
- No input
- ...

* Examples of code generators

- [[https://golang.org/cmd/go/#hdr-Test_packages][go test]]
  - Input: `*_test.go` Go source files
  - Output: `package`main` test program source file

- [[https://github.com/gopherjs/gopherjs][github.com/gopherjs/gopherjs]]
 - Input: Go source code
 - Output: JavaScript source code

- [[https://developers.google.com/protocol-buffers/][Protocol Buffers compiler]]
  - Input: .proto declarations
  - Output: Go source code, Java source code...

- [[https://godoc.org/golang.org/x/tools/cmd/stringer][golang.org/x/tools/cmd/stringer]]
  - Input: type declarations in Go code
  - Output: `String()` method for those types

* Today: we will focus on Go-based code generation

.image images/go_code_gen.png _ 800

* stringer: deep dive

Stringer is a tool to automate the creation of methods that satisfy the fmt.Stringer interface

- takes name of an integer type T that has constants defined
- creates a new Go source file implementing:

  func (t T) String() string

* stringer: input

    package painkiller
    
    type Pill int
    
    const (
    	Placebo Pill = iota
    	Aspirin
    	Ibuprofen
    	Paracetamol
    	Acetaminophen = Paracetamol
    )
    
    

* stringer: code generator

.image images/stringer_docs.png _ 900

* stringer: output

    // Code generated by "stringer -type=Pill"; DO NOT EDIT.
    
    package painkiller
    
    import "strconv"
    
    const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"
    
    var _Pill_index = [...]uint8{0, 7, 14, 23, 34}
    
    func (i Pill) String() string {
    	if i < 0 || i >= Pill(len(_Pill_index)-1) {
    		return "Pill(" + strconv.FormatInt(int64(i), 10) + ")"
    	}
    	return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
    }
    

* stringer: workflow

We could run stringer by hand

But doing so with potentially multiple code generators across multiple packages would be tedious.

* stringer: meet go generate

go generate helps automates the process of running code generators by scanning for special comments in Go source code that identify general commands to run.

These special comments are called directives:

    //go:generate stringer -type=Pill
    

We run go generate with a list of packages:

  go generate ./...

For more details see:

    $ go help generate
    usage: go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
    
    Generate runs commands described by directives within existing
    ...
    

* Go tool refresher

  $ go help
  ...
        build       compile packages and dependencies
        doc         show documentation for package or symbol
        get         download and install packages and dependencies
        install     compile and install packages and dependencies
        list        list packages or modules
        test        test packages
        ...         ...
        generate    generate Go files by processing source

- go generate is not part of go build
- no dependency analysis; must be run explicitly

* Writing our own simple code generator: typename

We will create stringer-esque code generator:

- take name of an integer type T
- create a new Go source file implementing:

  func (t T) TypeName() string

In effect we are writing a code generated version of:

    func (t T) TypeName() string {
    	return fmt.Sprintf("%T", t)
    }
    
    

* typename: process

- take a single type name as an argument
- parse Go source file using go/parser
- find type declaration in abstract syntax tree (AST)
- ensure it is an int type
- generate output file

* typename: implementation

We are creating a program:

    package main
    
    

Our program takes a single argument, the type name:

    func main() {
    	typeName := os.Args[1]
    ...
    

go generate sets some useful environment variables:

    	pkgName := os.Getenv("GOPACKAGE")
    	declFile := os.Getenv("GOFILE")
    

* typename: implementation

Parse the file containing the directive:

    	fset := token.NewFileSet()
    	f, err := parser.ParseFile(fset, declFile, nil, 0)
    	if err != nil {
    		log.Fatalf("failed to parse %v: %v", declFile, err)
    	}
    

* typename: implementation

Find the type declaration:

    Decls:
    	for _, d := range f.Decls {
    		switch d := d.(type) {
    		case *ast.GenDecl:
    			if d.Tok != token.TYPE {
    				continue Decls
    			}
    			for _, s := range d.Specs {
    				s := s.(*ast.TypeSpec)
    				if s.Name.Name != typeName {
    					continue Decls
    				}
    				if id, ok := s.Type.(*ast.Ident); ok && id.Name == "int" {
    					found = true
    					break Decls
    				}
    			}
    		}
    	}
    

* typename: implementation

Bail if we can't find the declaration:

    	if !found {
    		log.Fatalf("failed to find type declaration named %v of type int", typeName)
    	}
    

* typename: implementation

Prepare output:

    	output := fmt.Sprintf(`
    	package %[1]v
    	func (v %[2]v) TypeName() string {
    		return "%[2]v"
    	}
    	`, pkgName, typeName)
    	outfile := fmt.Sprintf("gen_%v_typename.go", typeName)
    

Write output:

    	if err := ioutil.WriteFile(outfile, []byte(output), 0666); err != nil {
    		log.Fatalf("failed to write output to %v: %v", outfile, err)
    	}
    

* typename: in action

    package main
    
    import "fmt"
    
    type GoSheffield int
    
    //go:generate typename GoSheffield
    
    func main() {
    	var gopher GoSheffield = 42
    	fmt.Printf("Today's special number is %v (%v)\n", gopher, gopher.TypeName())
    }
    

* typename: output

Run go generate:

    $ go generate .
    

Review generated file:

    package main
    
    func (v GoSheffield) TypeName() string {
    	return "GoSheffield"
    }
    

Run our program:

    $ go run .
    Today's special number is 42 (GoSheffield)
    

* typename: recap

- simple Go-based code generator
- looks at syntax of single input file only
- takes a single argument
- not robust in the presence of syntax errors
- not tested
- ...

* Where could we go from here?

- look at more than just structure of code; analyse types
- use [[https://godoc.org/golang.org/x/tools/go/packages][golang.org/x/tools/go/packages]] to help load syntax and type information
- be more robust in the presence of errors
- use conventions in your source code as hints for the code generator: type name prefix (i.e. template), special comments
- code generate "generic" data structures with [[https://github.com/ncw/gotemplate][github.com/ncw/gotemplate]]
- ...

* Problems with go generate

- no dependency analysis; have to run things "in right order"
- slow; always re-runs generators
- hard to chain generators together, or have generators themselves use code generation

: you don't have to do any of these things for go build/install

* Introducing gg

  myitcv.io/cmd/gg

- artefact cache-based wrapper around go generate directives
- import dependency aware
- generator dependency aware
- only re-runs generators if inputs change
- re-runs generators until a fixed point is reached
- much more simple to add code generation to your workflow
- see [[https://github.com/myitcv/x/blob/master/cmd/gg/README.md][the README]] for more details

* gg: run from cold

  # first round (4.133s)
  > gg -trace -p 1 ./...
  [stderr]
  go list -deps -test -json ./...
  hash commandDep commandDep: copy1
  generate {Pkg: mod [G]}
  ran generator: copy1 input1 2.00
  generate {Pkg: mod [G]}
  ran generator: copy1 input1 2.00
  hash {Pkg: mod [G]}

- copy1 takes an input file and copies it to create a generated output file
- copy1 also has a 2s sleep to simulate a long-running generator

* gg: cache hit

  # second round (0.126s)
  > gg -trace -p 1 ./...
  [stderr]
  go list -deps -test -json ./...
  hash commandDep commandDep: copy1
  hash {Pkg: mod [G]}

Please experiment with gg and report bugs!

*Bonus:* report bugs using a [[https://godoc.org/github.com/rogpeppe/go-internal/testscript][testscript]] test case!

* golang-tools

- golang-tools is a development list for Go Programming Language
- for discussion of the development of tools that analyze and manipulate Go source code
- including editor/IDE plugins (language server)
- also the #tools channel on Gophers Slack

See [[https://github.com/golang/go/wiki/golang-tools][the golang-tools wiki]] for more details.

* Today we have

- examined the principles of code generation
- discovered the main parts of a code generator
- looked at some popular code generators
- written a simple code generator
- seen how code generation fits into developer workflow
- inspired everyone to join the golang-tools community of tool builders!

.image images/tool_gopher.png 200 _
.caption Gopherize.me artwork courtesy of Ashley McNamara

* Links

- [[https://github.com/myitcv-talks-repos/code-gen][code from today's examples]]
- [[https://blog.golang.org/generate][go generate blog post]]
- [[https://godoc.org/golang.org/x/tools/cmd/stringer][stringer documentation]]
- [[https://godoc.org/go][standard library packages for handling Go code (parsing, type analysis etc)]]
- [[https://godoc.org/golang.org/x/tools/go/packages][convenience, modules-aware syntax and type loading]]


